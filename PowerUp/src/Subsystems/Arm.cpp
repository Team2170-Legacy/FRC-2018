// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Arm.h"
#include "../RobotMap.h"
#include <iostream>
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Arm::Arm() : frc::Subsystem("Arm") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    limitSwitchFront = RobotMap::armLimitSwitchFront;
    limitSwitchBack = RobotMap::armLimitSwitchBack;
    opticalFlagSensor = RobotMap::armOpticalFlagSensor;
    talonSRXArmMotor = RobotMap::armTalonSRXArmMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	talonSRXArmMotor->ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 0, 0);
	talonSRXArmMotor->SetSensorPhase(true);
	talonSRXArmMotor->SetSelectedSensorPosition(0, 0, 0);
}

void Arm::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Arm::Periodic() {
    // Put code here to be run every loop

}

// Put methods for controlling this subsystem
// here. Call these from Commands.

bool Arm::readLimitSwitchFront() {
	return !limitSwitchFront->Get();
	// Inversed due to Digital Output voltage pull-up (5V)
}

bool Arm::readLimitSwitchBack() {
	return !limitSwitchBack->Get();
	// Inversed due to Digital Output voltage pull-up (5V)
}

int Arm::readArmEncoder() {
	int pidIndex = 0;
	return talonSRXArmMotor->GetSelectedSensorPosition(pidIndex);
	// *** Check this!!! ***
}

bool Arm::readArmOpticalFlagSensor() {
	return opticalFlagSensor->Get();
}

void Arm::stopArmMotor() {
	talonSRXArmMotor->StopMotor();
}

double Arm::getArmPosition() {
	int encoderCounts = readArmEncoder();
	double kEncoder90Deg = ENCODER_COUNTS_PER_REV / 4;			// real value on 2018
	//double kEncoder90Deg = 5000.0;				// test value
	double angleDeg = (encoderCounts/kEncoder90Deg) * 90;
	//double angleDeg = encoderCounts;		//test
	return angleDeg * DEG;							// [radians]
}

void Arm::setArmMotorSpeed(double speed) {
	talonSRXArmMotor->Set(speed);
}

void Arm::resetArmEncoder() {
	int pidIndex = 0;
	int resetValue = 0;
	talonSRXArmMotor->SetSelectedSensorPosition(resetValue, pidIndex, 0);
	//talonSRXArmMotor->ConfigSelectedFeedbackSensor(FeedbackDevice::Analog, pidIndex, 0);
}

double Arm::getArmMotorTemp() {
	return talonSRXArmMotor->GetTemperature();
}

double Arm::setArmPosition(double alphaDesiredRad) {
	// Put CAN TALON in position mode
	//int armEncoder = readArmEncoder();
	//talonSRXArmMotor->Set(ControlMode::Position, armEncoder);

	// Perform calculations
	double kP_w = 0.1;			// Omega gain
	double wMax = 5.0;
	double Ts = 0.02;			// 50 Hz loop time

	double currentAlpha = getArmPosition();						// [radians]
	double e_alpha = alphaDesiredRad - currentAlpha; 			// [radians]
	double w = kP_w * e_alpha;									// [rad/sec]
	std::cout << w << "\t" << std::endl;
	if (w > wMax) {
		w = wMax;
	}
	else if (w < -wMax){
		w = -wMax;
	}

	double alphaDesired_CAN_TALON = currentAlpha + (w * Ts);		// [radians]
	//std::cout << alphaDesired_CAN_TALON << std::endl;

	// Now have CAN TALON go to that position
	//double calculatedPosition = alphaDesired_CAN_TALON

	// native units for encoder angle are: counts (??)
	double alphaDesired_CAN_TALON_native = alphaDesired_CAN_TALON / (2*PI) * ENCODER_COUNTS_PER_REV;
	std::cout << alphaDesired_CAN_TALON_native << std::endl;

	//talonSRXArmMotor->Set(ControlMode::Position, alphaDesired_CAN_TALON_native);
	return currentAlpha;
}

double Arm::encoderCountsToDeg(int encoderCounts) {
	return (encoderCounts / ENCODER_COUNTS_PER_REV) * ROTATION_DEG;
}

double Arm::degToEncoderCounts(double degrees) {
	return (degrees / ROTATION_DEG) * ENCODER_COUNTS_PER_REV;
}
double Arm::RadSecToNativeUnits(double radSec) {
	// From calculations, 1 native unit is 0.043633 rad/sec, which is 22.918 native units per rad/sec
	return radSec * 22.918433;
}

double Arm::getArmMotorVelocity() {
	int encoderCount = readArmEncoder();
	frc::Timer m_timer;
//	while (m_timer.Get() < 0.01) {
//		// wait
//	}
	return talonSRXArmMotor->GetSelectedSensorVelocity(0);
//	double radSec = 0;
//	if (m_timer.HasPeriodPassed(0.01)) {
//		encoderCount = (readArmEncoder() - encoderCount) * 100;		// [encoder counts / sec]
//		double rotationsSec = encoderCount / ENCODER_COUNTS_PER_REV;
//		radSec = rotationsSec * (2*PI);
//	}

//	return radSec;
}
